package main

import (
	"embed"
	"fmt"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/toxyl/flo"
)

//go:embed parser/*.go parser/*.tmpl
var parserFS embed.FS

// getParserFS returns the embedded filesystem containing parser files
func getParserFS() embed.FS {
	return parserFS
}

func cloneSourceFromFS(fs embed.FS, src, dst, pkg string) {
	if strings.HasPrefix(filepath.Base(src), "pkg_test") {
		// don't copy test files
		return
	}
	clone, err := fs.ReadFile(src)
	if err != nil {
		log.Fatal(err)
	}

	content := clone
	if !strings.HasSuffix(src, ".tmpl") {
		content = regexp.MustCompile(`(?m)^package .+?\n`).ReplaceAll(clone, fmt.Appendf(nil, `// DO NOT EDIT THIS FILE
// This file is automatically generated by go-dsl.
// Rerun go-dsl to update the language.
// Warning: Files prefixed with 'dsl_' or 'template_' will be removed,
// any manual changes will be lost.
`+"\npackage %s\n", pkg))
	}

	// For template files, use the original filename since they already have the template_ prefix
	if strings.HasSuffix(src, ".tmpl") {
		dst = filepath.Join(filepath.Dir(dst), filepath.Base(src))
	}

	if err := flo.File(dst).StoreBytes(content); err != nil {
		log.Fatal(err)
	}
}

func cleanupOldFiles(basePath string) {
	// Convert basePath to absolute path
	absBasePath, err := filepath.Abs(basePath)
	if err != nil {
		log.Fatal(err)
	}

	// Remove old dsl_*.go files
	goFiles, err := filepath.Glob(filepath.Join(absBasePath, "dsl_*.go"))
	if err != nil {
		log.Fatal(err)
	}
	for _, file := range goFiles {
		if err := flo.File(file).Remove(); err != nil {
			log.Fatal(err)
		}
	}

	// Remove old template_*.tmpl files
	tmplFiles, err := filepath.Glob(filepath.Join(absBasePath, "template_*.tmpl"))
	if err != nil {
		log.Fatal(err)
	}
	for _, file := range tmplFiles {
		if err := flo.File(file).Remove(); err != nil {
			log.Fatal(err)
		}
	}
}

func main() {
	if len(os.Args) < 6 {
		fmt.Println("Usage: go run main.go [id] [name] [description] [version] [extension] [package 1] [package 2] ... [package N]")
		os.Exit(1)
	}

	id := os.Args[1]
	name := os.Args[2]
	description := os.Args[3]
	version := os.Args[4]
	extension := os.Args[5]
	packages := os.Args[6:]

	for _, pkg := range packages {
		fmt.Printf("Generating parser for %s package\n", pkg)
		pkg = strings.TrimSpace(pkg)
		// read all files in the package
		files, err := filepath.Glob(pkg + "/*.go")
		if err != nil {
			log.Fatal(err)
		}

		var functions []metaFunc
		var variables []metaVar

		basePath := ""
		pkgName := ""

		// parse each file
		for _, file := range files {
			fmt.Println("Parsing file:", file)
			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
			if err != nil {
				log.Fatal(err)
			}
			if pkgName == "" {
				pkgName = node.Name.Name
			}
			if basePath == "" {
				basePath = strings.TrimPrefix(filepath.Dir(file), ".")
			}
			variables = extractVariableMeta(node, variables)
			functions = extractFunctionMeta(node, functions)
		}

		// Clean up old files before generating new ones
		cleanupOldFiles(basePath)

		// Get embedded files
		fs := getParserFS()

		// List all files in the parser directory
		entries, err := fs.ReadDir("parser")
		if err != nil {
			log.Fatal(err)
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}

			path := filepath.Join("parser", entry.Name())

			// Handle Go files - prefix with dsl_
			if strings.HasSuffix(entry.Name(), ".go") {
				cloneSourceFromFS(fs, path, basePath+"/dsl_"+entry.Name(), pkgName)
			}

			// Handle template files - they already have template_ prefix
			if strings.HasSuffix(entry.Name(), ".tmpl") {
				cloneSourceFromFS(fs, path, basePath+"/"+entry.Name(), pkgName)
			}
		}

		// generate the registry code
		code := genInitCode(id, name, description, version, extension, pkgName, functions, variables)

		// write to registry.go
		if err := flo.File(basePath + "/dsl_init.go").StoreString(code); err != nil {
			log.Fatal(err)
		}
	}
}
