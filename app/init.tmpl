// DO NOT EDIT THIS FILE
// This file is automatically generated by go-dsl.
// Rerun go-dsl to update the language.
// Warning: Files prefixed with `dsl_` or `template_` will be removed,
// any manual changes will be lost.

package {{ .Package }}

import ({{ range .Imports }}
    {{ . | printf "%q" }}{{ end }}
    "sync"
)

// NewLanguage creates a new isolated language instance
func NewLanguage() *dslCollection {
    l := &dslCollection{
        mu: &sync.Mutex{},
    }
    l.initDSL(
        {{ .ID | printf "%q" }}, 
        {{ .Name | printf "%q" }}, 
        {{ .Description | printf "%q" }},
        {{ .Version | printf "%q" }}, 
        {{ .Extension | printf "%q" }}, 
        dsl.defaultColorTheme(),
    )

    // By default your language can run all the functions
    // and use all the variables that have been defined below.
    //
    // If you ever need to reset the language to clear variables and functions
    // that have been added over time, you can do so by calling:
    //
    // l.restoreState()
    //
    // This will perform a full reset, which wipes all variables and
    // functions that have been created since the last time you called
    // l.vars.storeState() and l.funcs.storeState().
    //
    // You can also store the current state of the language by calling:
    //
    // l.storeState()

    // Register variables{{ range .VarRegistry }}
    l.vars.register(
        {{ .Name | printf "%q" }}, {{ .Type | printf "%q" }}, {{ .Unit | printf "%q" }}, {{ .Desc | printf "%q" }},
        {{ .Min }}, {{ .Max }}, {{ .Def }},
        func() any { return {{ .OrgName }} },
        func(a any) {
            r, _ := l.cast(a, {{ .Type | printf "%q" }})
            {{ .OrgName }} = r.({{ .Type }})
        },
    ){{ end }}
    l.vars.storeState() // Store the state of variables, so we can reset the language without losing them

    // Register functions{{ range .FuncRegistry }}
    l.funcs.register({{ .Name | printf "%q" }}, {{ .Desc | printf "%q" }},
        []dslParamMeta{ {{ range .Params }}
            { 
                name: {{ .Name | printf "%q" }},
                typ:  {{ .Type | printf "%q" }},{{ if not (eq .Min nil) }} 
                min:  {{ .Min | printf "%#v" }},{{ end }}{{ if not (eq .Max nil) }} 
                max:  {{ .Max | printf "%#v" }},{{ end }}{{ if not (eq .Def nil) }} 
                def:  {{ .Def | printf "%#v" }},{{ end }}{{ if .Unit }} 
                unit: {{ .Unit | printf "%q" }},{{ end }}{{ if .Desc }} 
                desc: {{ .Desc | printf "%q" }},{{ end }}
            },{{ end }}
        },
        []dslParamMeta{ {{ range .Returns }}    
            { 
                name: {{ .Name | printf "%q" }},
                typ:  {{ .Type | printf "%q" }},{{ if not (eq .Min nil) }} 
                min:  {{ .Min | printf "%#v" }},{{ end }}{{ if not (eq .Max nil) }} 
                max:  {{ .Max | printf "%#v" }},{{ end }}{{ if not (eq .Def nil) }} 
                def:  {{ .Def | printf "%#v" }},{{ end }}{{ if .Unit }} 
                unit: {{ .Unit | printf "%q" }},{{ end }}{{ if .Desc }} 
                desc: {{ .Desc | printf "%q" }},{{ end }}
            },{{ end }}
        },
        func(a ...any) (any, error) {
            return {{.OrgName}}({{ range $i, $t := .Params }}
                a[{{ .Index }}].({{ .Type }}),{{ end }} 
            )
        },
    ){{ end }}
    l.funcs.storeState() // Store the state of functions, so we can reset the language without losing them

    return l
}

func init() {
    dsl = *NewLanguage()
} 